type bool_expr =
| Var  of string
| Not of bool_expr
| And of bool_expr * bool_expr
| Or of bool_expr * bool_expr;;

let rec evaluate exp ass =
match exp with
| Var x -> List.assoc x ass
| Not e -> not (evaluate e ass)
| And (e1, e2) -> (evaluate e1 ass) && (evaluate e2 ass)
| Or (e1, e2) -> (evaluate e1 ass) || (evaluate e2 ass);;

(* Generate the truth table entries *)
let rec generate_combinations vars =
match vars with
| [] -> [[]]
| h :: t ->
let rest = generate_combinations t in
List.map (fun r -> (h, true) :: r) rest
@ List.map (fun r -> (h, false) :: r) rest;;

(* Add the truth value of the expression to the truth table generated by the previous function *)
let table vars exp =
let combinations = generate_combinations vars in
List.map (fun combo -> (combo, evaluate exp combo)) combinations